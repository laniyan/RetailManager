


go to solution and add new project sql server database 
Add a folder inside db solution schema name dbo and publishLocations//this is where we have our publish scripts publish to 
Add 3 folders inside dbo folder caleed views, tables and stored proc
right click the db solution click publish so we can create a profile then edit and go to browse click local and select mssql local db then click ok that will create a connection string for us
then type our db name and click save profile as click the publishLocation folder and leave the default name then click save (tim corey vid 5 sql db project 7:35) then click publish this creates a db
can check the db in sql server object explorer

Add new wpf project to solution call it app name + WPF + GUI incase we add more GUI so that we know the diff
then right click properties and change assmebly name to the project name i.e retail manager so when the assembly builds the .exe will be called the project name and not app name + WPF + GUI 
then right click the WPF project and click set as start up project
Then get rid of lil black debugging box go to tool then click options then scroll to debugging click that and pick genarally then scroll to and unclick show runtime tool in app
add caliburn.micro to the WPF project in nuget packages
now add a folder sturcature 3 folders Models, ViewModels (They have to be spelt correct or it wont work I spelled ViewsModels and the caliburn couldnt find the structre)
and Views we are using the mvvm framework (Models views viewsModel) Views is wot we display to the end user model holds the data the view is 
going to display and viewModels passes it to the view model is not data acces we hold our data access in a separte lib we slipt our concerns 
then add a class in viewModel called ShellViewModel all viewModel classes end with viewModel 
Then add a wondow to the view folder right click it and go to add then click window and call it ShellView we will make this replace the default window that was created for us
then add a class to then WPF project and call it bootstrapper we uses this to set up caliburn.micro
Then go to app.xaml and remove startupUri=mainWindow the in app.Resources tag add resourceDic.mergedDic tag then inside that add resourceDic tag and inside that add local:Bootstrapper with key Bootstrapper
now we can delete then default window (MainWindow.xaml)

use caliburn to do denpendcy injection useing simple container we wiried this up in the bootstrapper class 

Add a table and called user to dbo,table folder and right click go down to table click add entered table name(user) then added IDENTITY to the id field
we create more rows AuthUserId data typenvarchar 128 becoz the entity framework user db id uses nvarchar 128 we dont want to touch there db (Tim Corey vid 9 sql db 9:50 )
we add mores and the once that are the same as enitiy we map the data type we added CreatedDate and set data type to datetmie2 that new one datetime is legacy and they couldnt remove it because of that
we set the default value to getutcdate()because that is easier to convert to local after designing the tables I went to publishLocations folder right clicked RMData.publish click publish then click publish again

we use caliburn to to make our shell view handle multiple views inheriting conductor 
then add a dockpanel tag and put the grid tag inside it allows us to dock things in diff postions inside then create a menu inside there with to items file and account
Then create a new view model called loginViewModel and then the login view in the view folder right click then add user control call it LoginView then change the background color 2 white
we brought down the DesignHeight from 450 to 425 so we can still see the file and account tab from the shell view
then we made the login view load when the shell view starts using ctor injection for the login view in the shell view class
Connect tHead login view model to the login view by inheriting Screen in loginViewModel class screen is from caliburn and we have acces to notify() now we have attach the code
behind the screen like featuure file code and winUI in app forms 

Wire the api to the login screen create a api heleper class in helpers folder created a auth api call() create a method to init a httpclient set the base url in app config 
by creating a appsettings tag and a add tad wit atrr key = api and value = go to project dataManager right click go to prop the click web and cop project uri and paste as value
add a ref to config file in the WPFGUI solution right click ref then click aadd ref then select assemblies and type in serach box system.config then tick that box not the
one with installed at the end then press ok then we get the value using configurationManger class, to get the ReadAsAsync<string>() to work for use to read the response of
the api we have to add Microsoft.AspNet.WebApi.Client from nuget 
create a model in model folder called AuthenticatedUser and create prop for what The token api returns 
create a Interface of the api helper then add it to bootsrapper class we only want one instance of the api helper so we add it to singleton, in loginviewmodel in login()
this is where we want to call the APIHelper() so when they press login it will call the api
set multiple apps to start on start go to solution right click go to prop go to start proj and click multiple start proj and select the ones you want to start 
    (rmdata, wpfgui) then click apply now both widows opens

add error message for incorrect password on top of username added a extra row to login and push down username, password and login btn by changing the grid row value
add visibility collapse, Visibility="{Binding IsErrorVisible, Converter={StaticResource BooleanToVisibiltyConverter}} this method is built in to the WPF  we set the resource 
in app.xaml and give it a key static resource means from the resource dictionary BooleanToVisibiltyConverter converts a bool to visible or collapse true means visible false collapse
create a prop in loginView for is error visible and error message the isErrorVis prop will check to see if the api returns an error if it does then it returns true
then in the errorMessage prop we use NotifyOfPropChange() to see if IsErrorVisible prop has change and if it does we set to true or false then set error message to = api error message 

create a API library that can be reused over other projects not just this one so we dont want our lib to know anything about our WPF
delete class 1 then add class that will be our data access xall it SqlDataAccess create a connecr=tion string method make it return from config manager.connectionstring
that is saved in our app.config we set the value in our method then make it return the string library dont have a web config or app config it depends on the config of the exe
add couple of methods to get and set data we use dapper to help us do it its a nuget package dapper is a orm object relationship mapper like enitiy framework it dont generate
code like entity framework its fast and efficient and works well with store procs and theres now maintaning code like u have to with entity
Create a abstract class in our lib to get data we dont want our UI to know about store proc so it has no idea abt imp only cares about wot its recieving we call the class UserData
1st create a folder in lib called DataAccess
create another folder inside dataAccess and call it Internal and inside that create another folder called dataAccess and place the SqlDataAccess.cs inside it and make the class
internal because we dont want anything outside the lib to use it we use the UserData.cs as the interface to gain access to db all our internal helper methods we put in 
internal folder
create a models folder inside the lib project 
create a stored proc that gets the users first name, last name and email add based on user ID we go to the RMData dbo, stored proc folder add new stored proc and named it spUserLookup
create a usermodel class in model give it all the props reping the columns in the user table we want to retrive the values from 
create a method called GetUserById in UserData class
create a user controller in our RMDataManager controllers folder go to add new controller pick mvc5 write and read actions and add [Authorize]
at the top of the class then delete all route excpet for the details one change name to GetById make sure the class inherits from apiController coz we created a mvc controller 
it inherits from controller but this is an api so we want it to inherit from api controller now let it return the getUserById method return
go to publishLoca and publish our db again so that our stored proc is published 
go to the user table in the sql db and add a user the one we already created so now we can test the endpoint and see if it brings back the user copy the id from dbo.aspNetUsers
table (tim corey vid getting user 13 47:00)
create a connectionstring to our RMdata in web.config bcoz our stored proc is there right click the db RMData and go to prop and then copy connectionstring

Add a new project a class lib to the solution call it RMDesktopUI.Library we create this lib bcoz we dont want use the data manager lib coz it has data access and I dont want to give
the UI project data access this is for code to support UI i.e talking to api etc 
add a models folder to the new project lib call it LoggedInUserModel put the prop that we have in user model we dont inherit that class bcoz we want this lib to be independent
create a folder in new project called API move all Api helper methods from RMDataManagerWPFGUI project into this new folder then delete them from GUI project
install web api.client and update newtonsoft move AuthenticatedUser to the models folder of this project
create another method in api class GetLoggedInUserInfo that takes an args of a token add token prop to logged in user model create a interface for LoggedInUser and add it to 
bootstrapper.cs singleton now we pass the ILoggedInUserModel to the ctor of api helper then map that object to the return of the get LoggedInUser() and the token to wot was
passed in add Task GetLoggedInUserInfo(string token) to interface
add GetLoggedInUserInfo() to the LogIn() in RetailManagerWPFGUI ViewModels folder LoginViewModel.cs and pas token u get from the return of the Authenticate()(Tim Corey Vid getting user data 2 14 40:15)

Add sales page in view moedls folder add new class called salesviewmodel and inherit screen then add a user control to views folder call it salesView create the componnents
on salesViews pages and in salesVeiwModel create all the methods and props fpr the screen

Wire up the event EventAggregator so we can have some interform communication we want to hit the loggin button and that fires up the sale page to do this the sales view has
to know about the login event so we have to broadcast to the entire WPF app heres a new event and anyone listen for that event can then act apon it so now when log button is hit
and the user successfull logs in we will broadcast an event that will say hey somebody just logged in we wire up the shellview to listen to that event and then it will close the
login view page and create a sales page 
put the EventAggregator in the LoginViewModel ctor then to raise a event us the publish on ui thread method we want this when somebody logs in so do it in the LogIn()
create a folder in DesktopUI call eventModels inside it create a class called LogOnEvent this will be the key that we pass in our publish on ui thread method for anyone
who is listening can find what there looking for and you know exactly what its for (breakdown Tim Corey vid event agg 16 15:35 )
attach listener to shellview event in shellviewmodel class inherit IHandle and pass the logOnEvent class in the <> imp the Ihandel() so we are only listening to that event 
then reg the listening to log on events using the subscribe()
create the code we want excuted when event is trigged we want the sales view to appear so we use activateItem() can only have 1 activateItem so that will push the log in page back
but we want to destroy login page coz that will keep log in page there with the crdentail of last login user as its the obj we have in shellView with all the prop having vaules
if someone else goes on to log in page it will still have the values from the object so if they just have to press login so we can destroy it in two ways 1 create a clear() 
and call it in logIn() but if we add something later that sensitive and  forget to do the clear() 2 we can create a new instance of login that will overrite the old one we use
the container GetInstance() more info in shellViewModel Handle(LogOnEvent message) or we can just create the loginViewModel in the ctor as all viewModels are per request every
time we call the ShellView class it will give you a new login view model object wiping out any data it once had meaning u cant move back and forth from pages and still have 
the values u entered there with is correct behaviour for a login page 

Get the avaible items for sale from the db and throught the API and into our WPF project
we need a combine of two tables to populate the items column in salesView inventory and product table we change straigthy and just add acolumn to product table called quantityInStock check for breakdown(Tim corey display product 17 2:00 )
Create a stroed proc we create a stored proc for everything so we can have that final line of def in our dbthat way we scure our db to only have stored proc access that way we know it almost fully proctected
from sql injection and accidental modification to the table i.e deleting with out where clasues 
create a product controller use webApi empty framework
create a product model in dataManager lib inside models folder
create a productData class in data access folder in same project in there create the getAllProduct()
create a class in api folder called productEndpoint we call it this coz its not a full api we are only using it for products add IApiHelper init it in ctor the create a getall() add 
ApiClient prop to IApiHelper Add productModel to desktop lib then in getAll() then create Interface for product endpoint class then link it in bootstrapper as a PerRequest under container
create ctor in salesViewModel and put IproductEnpoint then create a overriden OnViewLoaded() and call LoadProducts() this will load the when the page is loading  

Select product and add it to the cart we want to wire that up
To add to a cart its simple because we already have a view model we can wire that up easy create a prop in salesViewmodel type is ProductModel call it selectedProduct in the set put notifyPropChange()
In salesView go to the textblock that has the item column in listbox and the Selected prop and bind it to the prop now everytime we select something in the items list it will put that model product
model in or selectedProduct prop put NotifyOfPropertyChange(() => Cart) and NotifyOfPropertyChange(() => SelectedProduct) this prop value is set by the gui we use it in the gui
we put SelectedItem="{Binding SelectedProduct}" in the item column
Add a CartItemModel to the UI lib add 3 prop product, QuantityInCart and displayText
create a full prop for selected product add 
create a Cart prop and a private cart field init the cart field with = new BindingList<CartItemModel>(); now the cart prop thats a list of cart items put NotifyOfPropertyChange(() => Cart)
in CanAddCart prop check to see if selected product quantity is more than item quantity (the quantity the user put) and item quantity is > 0 if is set to true this will enable the add cart btn
in AddCart() create a var to check if the selected product already exist in the cart if it does then just update quantity so we dont have the same product in the cart more than once then if it isnt
create a new CartItemModel and init it with the selected product and item quantity  then add it to the cart and take away the item quantity from the product quantity rest the item quantity and
put  NotifyOfPropertyChange(() => SubTotal); to trigger the subtotal 
imp the subtotal prop create a local subtotal var then do a foreach of the cart and then subtotal += item in the cart then return subtotal 
in cart column in the gui we use the cartItemModel prop display to text TextBlock Text="{Binding DisplayText}" that prop just returns product name and item quantity 

Add in the product table a field to see if its taxable set it to 1 (true) for default value add the new field to all the models
in tax prop inside saleViewModel put logic to determine the tax price 
create a folder called helper in desktop ui lib and create a class inside it called configHelper this will read configs from the app.config we will put the tax rate value there create a method in there
that gets the taxRate from config make the method return a decimal we have to convert the app.config value to a decimal from a string use try pasre if it cant throw an exception create an interface
then add it to bootstrapper class as a singleton and add it to the ctor in the sales veiw model then add the getTaxRate() to the tax prop 
create a private calculatesubtotal() and calculatetax() put the cal logic in there swap out wot we have in subTotal prop for it add the method to tax prop
in total prop use the two calculate method plus them against eachother and return the value thats our total amount 
add  NotifyOfPropertyChange(()) for tax and total to add to cart and remove from cart props 

refactor add foreign keys 1st in inventory table click foreign key on the right click and select add foreign key and enter FK_Inventory_ToProduct our productId in our inventory table maps to our id in 
product table becoz we dont call it product id in the product table we call it id we have to link it to that productId in this table we do that by adding a ref FOREIGN KEY ([ProductId]) REFERENCES Product (Id) 
do the same with sales for cashierId which links to user id there a very god reason y user id is a nvarchar(128) (Tim Corey vvid early refactoring 20 9:30) wired up saleDetail table with fk's
Changed the name of the entity framework db from aspnet-RMDataManager-20210601082611.mdf to EFData so its shorter and easier to rem swapped out defaultConnection the name of db and the catalog value 
all to ETData go to methods where we use the old values and swap them out i.e public class ApplicationDbContext : IdentityDbContext<ApplicationUser>  { public ApplicationDbContext() : base("ETData", throwIfV1Schema: false)
{} then run the enable-migrations command in package manager enable-migrations -ProjectName RMDataManager -StartUpProjectName RMDataManager -Verbose  the the updateDatabase command we do this to get ride 
of our old db the old name on to make our new name one take over
in shellveiwModel class we get ride of _container and use caliburn Ioc.Get() now we no longer ineed the SimpleContainer dependency 
change the item column in thw salesView page to show price and quantity in stock go to the item column in sales view wrap a stackPanel around the textblock set orientation to vertical then underneath
the texblock create 2 new stackpanel set orientation to horizontal in that stackpanel create two textblock one for the price one for the quantity and bind to Retail price and the other to quantity in stock 
wrap stackpanel around the textblocks create two textblocks for each element one for text name and other for binding 
had a bug I have to make sure wen delete a db and setting up a new that the entity db users table Id is the same as my user table id 

Post sales info to the db (wiring up both side the frontend and the api sides)
put taxrate key in web.config appsetting tag in RMDatamanager same as how its set in app.config
send over to our api is the cartItemModel and we only want prop productModel and from that the id with id we can look anything up and quantityIncart from CartItemModel
create a model to send the data over create it in the desktopui lib in model folder call it saleModel and create a saleDetailModel put to prop in there productId and
quantity in saleModel create a prop that takes a list of saleDetails call it saleDetails when we do a purchase we will send over just a sales model and that will have a
list of the saleDetails in it
in the Checkout() we need to create a sale model and post it to the api
in CanCheckOut prop we check if cart count is > 0 then set it to true that will enable the checkout btn put notify() for canCheckOut in remove() and Add() when ever
we remove we need to notify() and when we add we need to notifty as well 
in salesModel go to saleDetails prop and init an new list object
init a saleModel in checkOut() create a foreach to loop tru the cart prop and add the items to the saleModel obj now we post this to the api 
create the api to post the data so create a new api controler called saleController in dataManager project controller folder in that class put the auth attribute 
now create a front end saleModel in model folder of rmdm lib project coz there is no frontend only code we put it in the rmdm lib and a saleDetailModel put same prop
as we have in desktop lib although they look the same there not they are used diffrent so we cant just sometimes we may have classes that look the same but aint the
same so we cant just inherit the class we have to create them twice good breakdown in (Tim Corey vid 21 posting sales data 33:00 )
create a new class in the api folder desktop ui lib call it saleEndpoint create a ctor in that class for the api helper() this class will call the api to the sale endpoint
create a PostSale() that takes a saleModel from the ui and eventurlly will make a api post call to the sale table and pass the saleModel via the body
create a saleEndpoint Interface link it up in bootstrapper class
create a salesData class in dataManager lib dataAccess folder create a save sale method that takes a saleModel and will take 8 steps we use all these steps 
bcoz we dont trust the  frontend the frontend could of gave us all this step info so now we are verifying i.e checking at the front and the back
create a model in dm lib models folder call it saleDetailDBModel which model of the columns in the sale Details table 
convert the saleModel into a saleDetailDBModel create a new class called saleDbModel in rmdm lib models folder copy the colums from the sale table as props so we can map it
in productdata create a get product by id method
create a stored prop to get product by id then publish it
create a stored prop to insert data to sale table
create a stored prop to insert data to saleDetail table publish it
create a stored prop to get cashier by id from sale table publish it
create a another ConfigHelper class in rmdm lib add the key to appSetting in web cofig in rmdm project make the getTaxes() static this gives us the tax amount in our
SaleDate class so now we can work out the total price finish of the steps 
in sale controller inside post() put a saleModel obj in the arg and put a new saleData obj use the saveSale() and pass in the saleMoedl obj and the userId

Updating quantity in cart add and removing items
create a ui model in the desktop WPFUI project so we can notify change we dont want to do this in the UI lib coz we would have to modify our model and our model maps 
data from our api so we dont want to do that we call it CartItemDisplayModel put all props init same as CartItemModel but make product type be productDisplayModel 
then create a new model called productDisplayModel in CartItemDisplay inherit INotifyProp and imp it there and ProductDisplay prop
Add auto mapper from nuget to WPFUI proj this helps us with model transforamtion between layers bcoz we may be adding changing mulipating the model so its job is to
take the data from one model and move it over to a diffrernt model where the 2 model are close or hold same data 
add auto mappper denpendency injection system in configure() pur create new MapperConfiguration obj store it in a var in there config the obj you want to map
then create the mapper then pass it tru the container for the denpendency injection
Add mapper to the ctor of salesViewModel in there swap out all productModel for productDisplay same with CartItemModel to CartItemDisplay
create a mapper in LoadProduct() to map the model we get from the api to the new productDisplay model 
Take out the hack from addCart() take out the display prop from CartItemModel in UI lib
reactor config mapper put it in a private method then call th method in config()
